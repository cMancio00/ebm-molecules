from typing import Optional, Union, Sequence
import torch
from torch import Tensor
from torchmetrics import Metric
from torchmetrics.utilities.plot import _AX_TYPE, _PLOT_OUT_TYPE

from utils.graph import DenseData
from utils.mol import to_rdkit_mol
from rdkit import Chem

class Uniqueness(Metric):
    """
    The percentage of unique molecules generated by the model.
    A molecule is considered unique if it is unique in the generated batch.
    """

    is_differentiable: Optional[bool] = None
    higher_is_better: Optional[bool] = True
    plot_lower_bound: Optional[float] = None
    plot_upper_bound: Optional[float] = None

    def plot(self, val: Optional[Union[Tensor, Sequence[Tensor]]] = None,
             ax: Optional[_AX_TYPE] = None) -> _PLOT_OUT_TYPE:
        return self._plot(val, ax)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.add_state("unique", default=torch.tensor(0), dist_reduce_fx="sum")
        self.add_state("total", default=torch.tensor(0), dist_reduce_fx="sum")

    def update(self, generated_batch: DenseData, batch_size: int) -> None:
        if not isinstance(generated_batch, DenseData):
            raise ValueError("Can only compute uniqueness metrics on DenseData")

        inchi = set()
        for i in range(batch_size):
            x = generated_batch[i].x
            adj = generated_batch[i].adj
            mask = generated_batch[i].mask

            mol = to_rdkit_mol(x, adj, mask)
            inchi.add(Chem.MolToInchi(mol))

        self.unique += len(inchi)
        self.total += batch_size

    def compute(self) -> torch.Tensor:
        return self.unique.float() / self.total